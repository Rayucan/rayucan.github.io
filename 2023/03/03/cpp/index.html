<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="丁真"><meta name="copyright" content="丁真"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>C++ | 世界最高城理塘</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.25/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link id="light-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism.css" media="(prefers-color-scheme: light)"><link id="dark-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism-tomorrow.css" media="(prefers-color-scheme: dark)"><link rel="icon" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"example.com","root":"/","title":"世界最高城理塘","version":"1.6.1","mode":"dark","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><meta name="description" content="Hello World#include &lt;iostream&gt; #include &quot;windows.h&quot;  using namespace std;  int main(void)&amp;#123;     int a;     int b;      cout&lt;&lt;&quot;Please input a and b:\n&quot;;     cin&gt;&amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="C++">
<meta property="og:url" content="http://example.com/2023/03/03/cpp/index.html">
<meta property="og:site_name" content="世界最高城理塘">
<meta property="og:description" content="Hello World#include &lt;iostream&gt; #include &quot;windows.h&quot;  using namespace std;  int main(void)&amp;#123;     int a;     int b;      cout&lt;&lt;&quot;Please input a and b:\n&quot;;     cin&gt;&amp;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303032140356.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303032141945.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303032143943.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303032143500.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303032144350.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303032144866.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303032152747.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303032152890.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303032153298.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303032155798.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303032156502.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303032157325.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303032157098.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303042003574.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303042006338.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303042007285.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303042010051.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303042012769.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303042207414.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303042207686.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303042207677.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303052128573.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303052128205.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303052143518.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303052144959.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303061527827.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303062100261.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303062101217.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303062116313.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303071718583.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303101546593.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303101550650.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303101552350.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303101601919.png">
<meta property="article:published_time" content="2023-03-03T13:14:43.000Z">
<meta property="article:modified_time" content="2023-07-17T03:32:44.874Z">
<meta property="article:author" content="丁真">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303032140356.png"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="丁真"><img width="96" loading="lazy" src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/20210515231431.jpg" alt="丁真"></a><div class="site-author-name"><a href="/about/">丁真</a></div><a class="site-name" href="/about/site.html">世界最高城理塘</a><sub class="site-subtitle"></sub><div class="site-desciption">太美丽啦理塘！</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">52</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">2</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">8</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/Rayucan" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a></div></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Hello-World"><span class="toc-number">1.</span> <span class="toc-text">Hello World</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#iostream-%E4%B8%8E-iostream-h"><span class="toc-number">1.1.</span> <span class="toc-text">iostream 与 iostream.h</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">基本数据和表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.1.</span> <span class="toc-text">关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">2.2.</span> <span class="toc-text">标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%95%BF%E5%BA%A6"><span class="toc-number">2.3.1.</span> <span class="toc-text">数据类型长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#int"><span class="toc-number">2.3.2.</span> <span class="toc-text">int</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%81%E8%BF%9B%E5%88%B6%EF%BC%88Decimal-base-10%EF%BC%89"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">十进制（Decimal, base 10）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AB%E8%BF%9B%E5%88%B6%EF%BC%88Octal-Base-8%EF%BC%89"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">八进制（Octal, Base 8）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%EF%BC%88Hexadecimal-base-16%EF%BC%89"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">十六进制（Hexadecimal, base 16）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bool"><span class="toc-number">2.3.3.</span> <span class="toc-text">bool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#enum"><span class="toc-number">2.3.4.</span> <span class="toc-text">enum</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B%EF%BC%88float-double-long-double%EF%BC%89"><span class="toc-number">2.3.5.</span> <span class="toc-text">浮点型（float, double, long double）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%A4%BA%E6%95%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">常用示数方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A7%91%E5%AD%A6%E7%A4%BA%E6%95%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.5.2.</span> <span class="toc-text">科学示数方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#char"><span class="toc-number">2.3.6.</span> <span class="toc-text">char</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-number">2.3.6.1.</span> <span class="toc-text">转义字符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BF%E9%97%AE"><span class="toc-number">2.4.</span> <span class="toc-text">数据对象和访问</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">2.4.1.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%8F%98%E9%87%8F"><span class="toc-number">2.4.2.</span> <span class="toc-text">访问变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%AE%BF%E9%97%AE"><span class="toc-number">2.4.3.</span> <span class="toc-text">地址访问</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%B4%E5%9D%80%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">间址运算符</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="toc-number">2.4.4.</span> <span class="toc-text">指针变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-int-p-%E5%92%8C-p"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">区别 int *p 和 *p</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-int-%E5%92%8C-int"><span class="toc-number">2.4.4.2.</span> <span class="toc-text">区别 int 和 int *</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-p-%E5%92%8C-p"><span class="toc-number">2.4.4.3.</span> <span class="toc-text">输出 p 和 *p</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8C%87%E9%92%88%E5%AD%98%E5%82%A8%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="toc-number">2.4.4.4.</span> <span class="toc-text">交换指针存储的地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8C%87%E9%92%88%E6%89%80%E6%8C%87%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC"><span class="toc-number">2.4.4.5.</span> <span class="toc-text">交换指针所指变量的值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88"><span class="toc-number">2.4.4.6.</span> <span class="toc-text">空指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">2.4.4.7.</span> <span class="toc-text">指向指针的指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.4.4.8.</span> <span class="toc-text">指针类型转换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">2.4.5.</span> <span class="toc-text">引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">2.4.6.</span> <span class="toc-text">常量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88"><span class="toc-number">2.4.6.1.</span> <span class="toc-text">常量指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F"><span class="toc-number">2.4.6.2.</span> <span class="toc-text">指针常量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E5%B8%B8%E9%87%8F%E7%9A%84%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F"><span class="toc-number">2.4.6.3.</span> <span class="toc-text">指向常量的指针常量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E5%BC%95%E7%94%A8"><span class="toc-number">2.4.6.4.</span> <span class="toc-text">常引用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.4.7.</span> <span class="toc-text">表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.4.7.1.</span> <span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">2.4.7.2.</span> <span class="toc-text">运算符优先级</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E5%A4%9A%E4%B9%89%E6%80%A7"><span class="toc-number">2.4.7.3.</span> <span class="toc-text">运算符多义性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-%E5%8F%96%E4%BD%99%E8%BF%90%E7%AE%97"><span class="toc-number">2.4.7.4.</span> <span class="toc-text">C++ 取余运算 %</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="toc-number">2.5.</span> <span class="toc-text">数据输入和输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5"><span class="toc-number">2.5.1.</span> <span class="toc-text">输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA"><span class="toc-number">2.5.2.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B6%E7%AC%A6"><span class="toc-number">2.5.3.</span> <span class="toc-text">输出格式控制符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">程序控制结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%A7%E5%88%B6"><span class="toc-number">3.1.</span> <span class="toc-text">选择控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#if-%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.1.1.</span> <span class="toc-text">if 语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#switch-%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.1.2.</span> <span class="toc-text">switch 语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6"><span class="toc-number">3.2.</span> <span class="toc-text">循环控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#while-%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.2.1.</span> <span class="toc-text">while 语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#do-while-%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.2.2.</span> <span class="toc-text">do while 语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for-%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.2.3.</span> <span class="toc-text">for 语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E5%90%91%E6%8E%A7%E5%88%B6"><span class="toc-number">3.3.</span> <span class="toc-text">转向控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#break-%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.3.1.</span> <span class="toc-text">break 语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#continue-%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.3.2.</span> <span class="toc-text">continue 语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#goto-%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.3.3.</span> <span class="toc-text">goto 语句</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-number">4.1.</span> <span class="toc-text">函数定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">4.2.</span> <span class="toc-text">函数参数传递</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92"><span class="toc-number">4.2.1.</span> <span class="toc-text">值传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92"><span class="toc-number">4.2.2.</span> <span class="toc-text">指针传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-number">4.2.3.</span> <span class="toc-text">引用传递</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8"><span class="toc-number">4.3.</span> <span class="toc-text">递归调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">4.4.</span> <span class="toc-text">函数指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="toc-number">4.4.1.</span> <span class="toc-text">函数的地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">4.4.2.</span> <span class="toc-text">函数的指针</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.4.2.1.</span> <span class="toc-text">函数类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.4.2.2.</span> <span class="toc-text">定义函数类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="toc-number">4.4.2.3.</span> <span class="toc-text">定义指针变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">4.5.</span> <span class="toc-text">内联函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">4.6.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="toc-number">4.7.</span> <span class="toc-text">程序内存区域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%AD%98%E5%82%A8%E7%B1%BB"><span class="toc-number">4.7.1.</span> <span class="toc-text">自动存储类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E7%B1%BB"><span class="toc-number">4.7.2.</span> <span class="toc-text">静态存储类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.8.</span> <span class="toc-text">标识符作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.8.1.</span> <span class="toc-text">函数原型作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.8.2.</span> <span class="toc-text">块作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.8.3.</span> <span class="toc-text">函数作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.8.4.</span> <span class="toc-text">文件作用域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">4.9.</span> <span class="toc-text">全局变量和局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="toc-number">4.10.</span> <span class="toc-text">预处理指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E7%BC%96%E8%AF%91%E5%99%A8%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">4.10.1.</span> <span class="toc-text">C++ 编译器工作过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB"><span class="toc-number">4.10.2.</span> <span class="toc-text">文件包含</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="toc-number">4.10.3.</span> <span class="toc-text">条件编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">4.10.4.</span> <span class="toc-text">宏定义</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%B8%A6%E5%8F%82%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">4.10.4.1.</span> <span class="toc-text">不带参宏定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%A6%E5%8F%82%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">4.10.4.2.</span> <span class="toc-text">带参宏定义</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">4.11.</span> <span class="toc-text">命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">4.11.1.</span> <span class="toc-text">标准名空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A0%87%E5%87%86%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">4.11.2.</span> <span class="toc-text">使用标准名空间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">5.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">5.1.</span> <span class="toc-text">一维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">5.1.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.1.2.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE"><span class="toc-number">5.1.3.</span> <span class="toc-text">下标访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE"><span class="toc-number">5.1.4.</span> <span class="toc-text">指针访问</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84"><span class="toc-number">5.2.</span> <span class="toc-text">指针数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0%E7%9A%84%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84"><span class="toc-number">5.2.1.</span> <span class="toc-text">指向基本元素的指针数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84"><span class="toc-number">5.2.2.</span> <span class="toc-text">指向数组的指针数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84"><span class="toc-number">5.2.3.</span> <span class="toc-text">指向函数的指针数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">5.3.</span> <span class="toc-text">二维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE-1"><span class="toc-number">5.3.1.</span> <span class="toc-text">下标访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE-1"><span class="toc-number">5.3.2.</span> <span class="toc-text">指针访问</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%82%E5%85%83%E7%B4%A0%E5%9C%B0%E5%9D%80"><span class="toc-number">5.3.2.1.</span> <span class="toc-text">求元素地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%82%E5%85%83%E7%B4%A0%E7%9A%84%E5%80%BC"><span class="toc-number">5.3.2.2.</span> <span class="toc-text">求元素的值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">5.3.2.3.</span> <span class="toc-text">应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">5.4.</span> <span class="toc-text">一维数组作为函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">5.5.</span> <span class="toc-text">二维数组作为函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%AD%98%E5%82%A8"><span class="toc-number">5.6.</span> <span class="toc-text">动态存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#new-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.6.1.</span> <span class="toc-text">new 操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#delete-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.6.2.</span> <span class="toc-text">delete 操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-1"><span class="toc-number">5.6.3.</span> <span class="toc-text">应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.7.</span> <span class="toc-text">字符数组与字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E5%AD%98%E6%94%BE%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.7.1.</span> <span class="toc-text">用字符数组存放字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%E7%AE%A1%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.7.2.</span> <span class="toc-text">用字符指针管理字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">5.7.3.</span> <span class="toc-text">字符串的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.7.4.</span> <span class="toc-text">输入字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E4%BE%8B"><span class="toc-number">5.7.5.</span> <span class="toc-text">特例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-number">5.7.6.</span> <span class="toc-text">字符串函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-number">6.</span> <span class="toc-text">结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84"><span class="toc-number">6.1.</span> <span class="toc-text">定义结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E5%8F%8A%E5%8F%98%E9%87%8F"><span class="toc-number">6.2.</span> <span class="toc-text">定义结构及变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E7%BB%93%E6%9E%84"><span class="toc-number">6.3.</span> <span class="toc-text">访问结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE-2"><span class="toc-number">6.3.1.</span> <span class="toc-text">指针访问</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80"><span class="toc-number">6.3.1.1.</span> <span class="toc-text">方式一</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C"><span class="toc-number">6.3.1.2.</span> <span class="toc-text">方式二</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%90%8C%E7%9A%84%E7%BB%93%E6%9E%84%E5%8F%98%E9%87%8F%E5%8F%AF%E4%BB%A5%E7%9B%B8%E4%BA%92%E8%B5%8B%E5%80%BC"><span class="toc-number">6.3.1.3.</span> <span class="toc-text">类型相同的结构变量可以相互赋值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E6%95%B0%E7%BB%84"><span class="toc-number">6.4.</span> <span class="toc-text">结构数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E5%8E%9F%E5%88%99"><span class="toc-number">6.5.</span> <span class="toc-text">结构内存对齐原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-number">6.5.1.</span> <span class="toc-text">练习</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%EF%BC%9F"><span class="toc-number">6.5.2.</span> <span class="toc-text">为什么需要内存对齐？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%82%E7%82%B9%E4%B8%80%EF%BC%9A%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7"><span class="toc-number">6.5.2.1.</span> <span class="toc-text">观点一：可移植性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%82%E7%82%B9%E4%BA%8C%EF%BC%9A%E6%80%A7%E8%83%BD"><span class="toc-number">6.5.2.2.</span> <span class="toc-text">观点二：性能</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://example.com/2023/03/03/cpp/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="丁真"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="世界最高城理塘"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">C++</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="Created: 2023-03-03 21:14:43" itemprop="dateCreated datePublished" datetime="2023-03-03T21:14:43+08:00">2023-03-03</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="Modified: 2023-07-17 11:32:44" itemprop="dateModified" datetime="2023-07-17T11:32:44+08:00">2023-07-17</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E7%AC%94%E8%AE%B0/" style="--text-color:dimgray" itemprop="url" rel="index"><span itemprop="text">笔记</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/C/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">C++</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &quot;windows.h&quot;

using namespace std;

int main(void)&#123;
    int a;
    int b;

    cout&lt;&lt;&quot;Please input a and b:\n&quot;;
    cin&gt;&gt;a;
    cin&gt;&gt;b;

    cout&lt;&lt;&quot;a+b&#x3D;&quot;;
    cout&lt;&lt;a+b;

    system(&quot;pause&quot;);
    return 0;
&#125;</code></pre>

<blockquote>
<p>在 VS Code 中运行 C++ 代码会出现控制台窗口闪退的问题</p>
<p>在代码中加入 <code>#include &quot;windows.h&quot;</code> 和 <code>system(&quot;pause&quot;);</code> 可以解决</p>
</blockquote>
<h3 id="iostream-与-iostream-h"><a href="#iostream-与-iostream-h" class="headerlink" title="iostream 与 iostream.h"></a>iostream 与 iostream.h</h3><p><code>#include &lt;iostream.h&gt;  </code> 是非标准输入输出流，标准化前的头文件</p>
<p><code>#include &lt;iostream&gt;</code> 是标准输入输出流，标准化后的头文件，需要配合命名空间使用 <code>using namespace std;</code></p>
<h2 id="基本数据和表达式"><a href="#基本数据和表达式" class="headerlink" title="基本数据和表达式"></a>基本数据和表达式</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><pre class="language-none"><code class="language-none">auto    break    case    char    class    const    continue    default    delete    else
enum    explicit    extern    float    for    friend    goto    if    inline    int    long 
new    operator   private    protected    public    register    return    short    signed 
sizeof    static    struct    switch    this    typedef    union    unsigned    virtual    
void    while</code></pre>

<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>以<strong>字母、下划线</strong>开始，由<strong>字母、下划线、数字</strong>组成的字符串</p>
<ul>
<li>不能使用关键字</li>
<li>区分大小写</li>
<li>长度无规定</li>
</ul>
<p>合法：</p>
<pre class="language-none"><code class="language-none">a    x1    no_1    _a2c    sum    Name    name</code></pre>

<p>非法：</p>
<pre class="language-none"><code class="language-none">2a    x+y    a,b    a&amp;b    const </code></pre>

<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303032140356.png" alt="image-20230303214001084" loading="lazy"></p>
<h4 id="数据类型长度"><a href="#数据类型长度" class="headerlink" title="数据类型长度"></a>数据类型长度</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>byte<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>boolean<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<pre class="language-none"><code class="language-none">1
2
4
4
4
8
1
1

4
8</code></pre>

<table>
<thead>
<tr>
<th align="center">byte</th>
<th align="center">short</th>
<th align="center">int</th>
<th align="center">long</th>
<th align="center">float</th>
<th align="center">double</th>
<th align="center">boolean</th>
<th align="center">char</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">8</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">long int</th>
<th align="center">long long</th>
</tr>
</thead>
<tbody><tr>
<td align="center">4</td>
<td align="center">8</td>
</tr>
</tbody></table>
<h4 id="int"><a href="#int" class="headerlink" title="int"></a>int</h4><h5 id="十进制（Decimal-base-10）"><a href="#十进制（Decimal-base-10）" class="headerlink" title="十进制（Decimal, base 10）"></a>十进制（Decimal, base 10）</h5><p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303032141945.png" alt="image-20230303214114783" loading="lazy"></p>
<h5 id="八进制（Octal-Base-8）"><a href="#八进制（Octal-Base-8）" class="headerlink" title="八进制（Octal, Base 8）"></a>八进制（Octal, Base 8）</h5><p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303032143943.png" alt="image-20230303214330756" loading="lazy"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303032143500.png" alt="image-20230303214353443" loading="lazy"></p>
<h5 id="十六进制（Hexadecimal-base-16）"><a href="#十六进制（Hexadecimal-base-16）" class="headerlink" title="十六进制（Hexadecimal, base 16）"></a>十六进制（Hexadecimal, base 16）</h5><p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303032144350.png" alt="image-20230303214439192" loading="lazy"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303032144866.png" alt="image-20230303214458727" loading="lazy"></p>
<h4 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h4><p>只有两个值：<code>true</code> 和 <code>false</code></p>
<h4 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h4><p>枚举类型，用标识符代替在列表中的序号</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &quot;windows.h&quot;

using namespace std;

enum color&#123;red, blue, green&#125;;

int main(void)&#123;
    color c;

    c &#x3D; green;
    cout &lt;&lt; c;

    system(&quot;pause&quot;);
    return 0;
&#125;</code></pre>

<pre class="language-none"><code class="language-none">2</code></pre>

<p>red = 0</p>
<p>blue = 1</p>
<p>green = 2</p>
<h4 id="浮点型（float-double-long-double）"><a href="#浮点型（float-double-long-double）" class="headerlink" title="浮点型（float, double, long double）"></a>浮点型（float, double, long double）</h4><p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303032152747.png" alt="image-20230303215237667" loading="lazy"></p>
<h5 id="常用示数方式"><a href="#常用示数方式" class="headerlink" title="常用示数方式"></a>常用示数方式</h5><p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303032152890.png" alt="image-20230303215255719" loading="lazy"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303032153298.png" alt="image-20230303215313162" loading="lazy"></p>
<h5 id="科学示数方式"><a href="#科学示数方式" class="headerlink" title="科学示数方式"></a>科学示数方式</h5><p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303032155798.png" alt="image-20230303215552595" loading="lazy"></p>
<h4 id="char"><a href="#char" class="headerlink" title="char"></a>char</h4><p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303032156502.png" alt="image-20230303215636357" loading="lazy"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303032157325.png" alt="image-20230303215700154" loading="lazy"></p>
<h5 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h5><p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303032157098.png" alt="image-20230303215735835" loading="lazy"></p>
<h3 id="数据对象和访问"><a href="#数据对象和访问" class="headerlink" title="数据对象和访问"></a>数据对象和访问</h3><p>程序使用内存单元存放数据，且可以对内存单元进行命名（标识符）</p>
<p>对内存的<strong>读、写</strong>称为访问</p>
<p><strong>既能读，又能写</strong>的<strong>内存对象</strong>称为变量</p>
<p>一旦初始化就不能修改的内存对象称为常量</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>变量是存储单元</p>
<p>变量定义：申请指定类型的存储空间，并以指定标识符命名</p>
<h4 id="访问变量"><a href="#访问变量" class="headerlink" title="访问变量"></a>访问变量</h4><p>内存单元由操作系统按<strong>字节（Byte）</strong>编号，称为地址</p>
<p>一个对象占有内存的<strong>第一个字节的地址</strong>称为对象的地址</p>
<p>可以通过<strong>对象名</strong>或<strong>地址</strong>访问对象</p>
<p>数据对象有两种访问形式：读、写</p>
<h4 id="地址访问"><a href="#地址访问" class="headerlink" title="地址访问"></a>地址访问</h4><p>程序编译后，系统对已声明对象生成一张名表，登记对象的属性</p>
<pre class="language-none"><code class="language-none">&lt;名字，类型，地址&gt;</code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303042003574.png" alt="image-20230304200316406" loading="lazy"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303042006338.png" alt="image-20230304200615232" loading="lazy"></p>
<p>C++ 允许通过名或地址访问对象</p>
<h5 id="间址运算符"><a href="#间址运算符" class="headerlink" title="间址运算符"></a>间址运算符</h5><p>以下两种方式是等效的：<code>a == *(&amp;a)</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303042007285.png" alt="image-20230304200743175" loading="lazy"></p>
<h4 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h4><p>能够存放对象地址的变量</p>
<ul>
<li><code>&amp;</code> 取地址</li>
<li><code>*</code> 间址访问</li>
</ul>
<p>下图，<code>a == *p1</code>，<code>b == *p2</code>，两者等效</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303042010051.png" alt="image-20230304201052926" loading="lazy"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303042012769.png" alt="image-20230304201227624" loading="lazy"></p>
<h5 id="区别-int-p-和-p"><a href="#区别-int-p-和-p" class="headerlink" title="区别 int *p 和 *p"></a>区别 int *p 和 *p</h5><p>前者是指针定义，后者是指针所指向的变量</p>
<h5 id="区别-int-和-int"><a href="#区别-int-和-int" class="headerlink" title="区别 int 和 int *"></a>区别 int 和 int *</h5><p>若编译以下代码则会报错：</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int i &#x3D; 1;
int *p;

p &#x3D; i;</code></pre>

<pre class="language-none"><code class="language-none">不能将 &quot;int&quot; 类型的值分配到 &quot;int *&quot; 类型的实体</code></pre>

<p>即类型不匹配，<code>int</code> 和 <code>int *</code> 不属于同种类型</p>
<h5 id="输出-p-和-p"><a href="#输出-p-和-p" class="headerlink" title="输出 p 和 *p"></a>输出 p 和 *p</h5><pre class="language-c++" data-language="c++"><code class="language-c++">int i &#x3D; 1;
int *p &#x3D; &amp;i;

cout &lt;&lt; p; &#x2F;&#x2F;输出存放的地址</code></pre>

<pre class="language-none"><code class="language-none">0x61ff08</code></pre>

<pre class="language-c++" data-language="c++"><code class="language-c++">int i &#x3D; 1;
int *p &#x3D; &amp;i;

cout &lt;&lt; *p; &#x2F;&#x2F;输出指向变量的值</code></pre>

<pre class="language-none"><code class="language-none">1</code></pre>

<h5 id="交换指针存储的地址"><a href="#交换指针存储的地址" class="headerlink" title="交换指针存储的地址"></a>交换指针存储的地址</h5><pre class="language-c++" data-language="c++"><code class="language-c++">int a &#x3D; 1;
int b &#x3D; 2;

int *p1 &#x3D; &amp;a;
int *p2 &#x3D; &amp;b;

int *p;
p &#x3D; p1;
p1 &#x3D; p2;
p2 &#x3D; p;

cout &lt;&lt; *p1;</code></pre>

<pre class="language-none"><code class="language-none">2</code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303042207414.png" alt="image-20230304203831437" loading="lazy"></p>
<h5 id="交换指针所指变量的值"><a href="#交换指针所指变量的值" class="headerlink" title="交换指针所指变量的值"></a>交换指针所指变量的值</h5><pre class="language-c++" data-language="c++"><code class="language-c++">int a &#x3D; 1;
int b &#x3D; 2;

int *p1 &#x3D; &amp;a;
int *p2 &#x3D; &amp;b;

int temp;
temp &#x3D; *p1;
*p1 &#x3D; *p2;
*p2 &#x3D; temp;

cout &lt;&lt; a;</code></pre>

<pre class="language-none"><code class="language-none">2</code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303042207686.png" alt="image-20230304203816465" loading="lazy"></p>
<h5 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h5><p>以下两种方式均可以创建空指针：</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int *p &#x3D; 0;
int *p &#x3D; null;</code></pre>

<h5 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h5><pre class="language-c++" data-language="c++"><code class="language-c++">int **pp;
int *p;
int i &#x3D; 1;

p &#x3D; &amp;i;
pp &#x3D; &amp;p;

cout &lt;&lt; p &lt;&lt; endl;
cout &lt;&lt; *p &lt;&lt; endl;

cout &lt;&lt; pp &lt;&lt; endl;
cout &lt;&lt; *pp &lt;&lt; endl;
cout &lt;&lt; **pp &lt;&lt; endl;</code></pre>

<pre class="language-none"><code class="language-none">0x61ff04 &#x2F;&#x2F; 指针 p 存放的地址，即 i 的地址
1 &#x2F;&#x2F; *p 

0x61ff08 &#x2F;&#x2F; 指针 pp 存放的地址，即指针 p 自身的地址 
0x61ff04 &#x2F;&#x2F; 指针 *pp 存放的地址，即指针 p 存放的地址，即 i 的地址
1 &#x2F;&#x2F; **pp</code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303042207677.png" alt="image-20230304220611132" loading="lazy"></p>
<h5 id="指针类型转换"><a href="#指针类型转换" class="headerlink" title="指针类型转换"></a>指针类型转换</h5><pre class="language-c++" data-language="c++"><code class="language-c++">int *intPointer;
char *charPointer;

int i &#x3D; 65;
intPointer &#x3D; &amp;i;

charPointer &#x3D; (char *)intPointer;

cout &lt;&lt; *charPointer &lt;&lt; endl;</code></pre>

<pre class="language-none"><code class="language-none">A</code></pre>

<p>ascii 码表中，十进制 <code>65</code> 对应的字符为 <code>A</code></p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><pre class="language-c++" data-language="c++"><code class="language-c++">int i;
int *p;
int &amp;iRefer &#x3D; i;

i &#x3D; 1;
p &#x3D; &amp;i;

cout &lt;&lt; i &lt;&lt; endl;
cout &lt;&lt; *p &lt;&lt; endl;
cout &lt;&lt; iRefer &lt;&lt; endl;</code></pre>

<pre class="language-none"><code class="language-none">1
1
1</code></pre>

<p><code>iRefer</code> 相当于 <code>i</code>  的别名，且<strong>必须在定义时初始化</strong></p>
<p><code>i == *p == iRefer</code>，三者等效</p>
<p>注意区别 <code>int &amp;</code> 和 <code>&amp;i</code>，前者是引用，后者是取地址符</p>
<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>关键字 <code>const</code> 可以约束访问对象的权限，使其<strong>只能读，不能写，不允许修改对象的值</strong></p>
<pre class="language-none"><code class="language-none">const double PI &#x3D; 3.14;
const int MAX &#x3D; 666;</code></pre>

<h5 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h5><p>const 在星号之前</p>
<p><code>const 类型 * 指针名</code></p>
<p><code>类型 const * 指针名</code></p>
<p>常量指针，既可以指向常量，也可以指向变量，但是<strong>若指向变量，则不能修改指向的变量值</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">const int i &#x3D; 114514;
int j &#x3D; 1919;

const int *p &#x3D; &amp;i;
p &#x3D; &amp;j;

&#x2F;&#x2F;报错，不能通过常量指针修改变量值
&#x2F;&#x2F;*p &#x3D; 666;

cout &lt;&lt; *p &lt;&lt; endl;</code></pre>

<pre class="language-none"><code class="language-none">1919</code></pre>

<h5 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h5><p>const 在星号之后，注意与常量指针区分</p>
<p><code>类型 * const 指针名</code></p>
<p>指针常量，其中保存的地址不可改变，即<strong>不可再指向别的变量</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int i &#x3D; 114514;
int j &#x3D; 1919;

int * const p &#x3D; &amp;i;

&#x2F;&#x2F;报错，不可修改指针保存的地址
&#x2F;&#x2F;p &#x3D; &amp;j;

cout &lt;&lt; *p &lt;&lt; endl;</code></pre>

<h5 id="指向常量的指针常量"><a href="#指向常量的指针常量" class="headerlink" title="指向常量的指针常量"></a>指向常量的指针常量</h5><p>星号两边都有 const</p>
<p><code>const 类型 * const 指针名</code></p>
<p>指向常量的指针常量：</p>
<ul>
<li>指针保存的地址不可修改</li>
<li>指针指向的常量值不可修改</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">const int i &#x3D; 114514;
const int * const p &#x3D; &amp;i;

cout &lt;&lt; *p &lt;&lt; endl;</code></pre>

<h5 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h5><p><code>const 类型 &amp; 引用名</code></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int i &#x3D; 114514;
const int &amp; refer &#x3D; i;

&#x2F;&#x2F;报错，不能通过常引用修改变量值
&#x2F;&#x2F;refer &#x3D; 1919;

cout &lt;&lt; refer &lt;&lt; endl;</code></pre>

<h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><p>由数据和运算符，按一定规则，表达某个值的式子</p>
<h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303052128573.png" alt="image-20230305212820289" loading="lazy"></p>
<p>运算符可分为：</p>
<ul>
<li><p>单目运算符：<code>运算符 右操作数</code></p>
<p><code>-123</code> <code>+500</code></p>
</li>
<li><p>双目运算符：<code>左操作数 运算符 右操作数</code></p>
<p><code>a + 1</code> <code>x &gt; y</code></p>
</li>
<li><p>三目运算符：<code>操作数1 ? 操作数2 : 操作数3</code></p>
<p><code>a ? b : c</code></p>
</li>
</ul>
<h5 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h5><p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303052128205.png" alt="image-20230305212844044" loading="lazy"></p>
<h5 id="运算符多义性"><a href="#运算符多义性" class="headerlink" title="运算符多义性"></a>运算符多义性</h5><pre class="language-c++" data-language="c++"><code class="language-c++">int a &#x3D; 1;

&#x2F;&#x2F; 引用说明符
int &amp;ra &#x3D; a;

&#x2F;&#x2F; 指针说明符 取址运算符
int *p &#x3D; &amp;a;

&#x2F;&#x2F; 算术乘法
a &#x3D; ra * 6;

&#x2F;&#x2F; 间址访问 算术乘法
*p &#x3D; 5 * *p; &#x2F;&#x2F; 等同于 *p &#x3D; 5 * (*p)

cout &lt;&lt; *p &lt;&lt; endl;</code></pre>

<pre class="language-none"><code class="language-none">30</code></pre>

<h5 id="C-取余运算"><a href="#C-取余运算" class="headerlink" title="C++ 取余运算 %"></a>C++ 取余运算 <code>%</code></h5><p>c++ 中 <code>%</code> 运算符为<strong>取余</strong>，而不是取模</p>
<p> <code>a % b</code>：</p>
<ul>
<li>计算整数商：<code>c = a / b</code>（向 0 方向取整，如 1.5 取 1，-1.5 取 -1）</li>
<li>计算余数：<code>r = a - c * b</code></li>
</ul>
<h3 id="数据输入和输出"><a href="#数据输入和输出" class="headerlink" title="数据输入和输出"></a>数据输入和输出</h3><p>c++ 的输入输出操作由 IO 流库提供</p>
<p><code>cin</code>、<code>cout </code> 是 IO 流库定义的两个标准对象，在 <code>iostream.h</code> 头文件中声明</p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p><code>cin &gt;&gt; 变量1 &gt;&gt; 变量2 &gt;&gt; 变量3 &gt;&gt; ... </code></p>
<p>这里的 <code>&gt;&gt;</code> 是<strong>提取运算符</strong>，不是位运算符</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p><code>cout &lt;&lt; 表达式1 &lt;&lt; 表达式2 &lt;&lt; 表达式3 &lt;&lt; ...</code></p>
<p>这里的 <code>&lt;&lt;</code> 是<strong>插入运算符</strong>，不是位运算符</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303052143518.png" alt="image-20230305214343257" loading="lazy"></p>
<h4 id="输出格式控制符"><a href="#输出格式控制符" class="headerlink" title="输出格式控制符"></a>输出格式控制符</h4><p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303052144959.png" alt="image-20230305214406792" loading="lazy"></p>
<h2 id="程序控制结构"><a href="#程序控制结构" class="headerlink" title="程序控制结构"></a>程序控制结构</h2><h3 id="选择控制"><a href="#选择控制" class="headerlink" title="选择控制"></a>选择控制</h3><h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h4><h4 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h4><pre class="language-c++" data-language="c++"><code class="language-c++">switch(表达式)&#123;
    case 常量表达式:
       ...
       break; 
    case 常量表达式:
       ...
       break; 
  
    default:
       ...
&#125;</code></pre>

<ul>
<li>表达式必须为整型、枚举类型，不能为浮点型</li>
<li>常量表达式必须是常量，且与 switch 括号中的变量类型一致</li>
<li>default 可选</li>
</ul>
<h3 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h3><h4 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h4><h4 id="do-while-语句"><a href="#do-while-语句" class="headerlink" title="do while 语句"></a>do while 语句</h4><h4 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h4><pre class="language-c++" data-language="c++"><code class="language-c++">for(表达式1;表达式2;表达式3)&#123;
    ...
&#125;</code></pre>

<p>表达式 1、表达式 2、表达式 3 均可省略</p>
<h3 id="转向控制"><a href="#转向控制" class="headerlink" title="转向控制"></a>转向控制</h3><h4 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h4><h4 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h4><h4 id="goto-语句"><a href="#goto-语句" class="headerlink" title="goto 语句"></a>goto 语句</h4><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li>函数（Function）是功能抽象模块</li>
<li>函数的作用：任务划分、代码重用</li>
</ul>
<h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>由两部分组成：函数头、函数体</p>
<pre class="language-none"><code class="language-none">返回值类型 函数名( 参数列表 )&#123;
   ...
&#125;</code></pre>

<p>如</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int getMax(int x, int y)&#123;
    if(x &gt; y)&#123;
        return x;
    &#125;else &#123;
        return y;
    &#125;
&#125;</code></pre>

<h3 id="函数参数传递"><a href="#函数参数传递" class="headerlink" title="函数参数传递"></a>函数参数传递</h3><h4 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h4><p>把传入参数（实际参数）的值复制给函数的形式参数，在这种情况下，修改函数内部的形参<strong>不会改变</strong>实参</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 函数定义
void swap(int x, int y)
&#123;
   int temp;
 
   temp &#x3D; x; &#x2F;* 保存 x 的值 *&#x2F;
   x &#x3D; y;    &#x2F;* 把 y 赋值给 x *&#x2F;
   y &#x3D; temp; &#x2F;* 把 x 赋值给 y *&#x2F;
  
   return;
&#125;</code></pre>

<pre class="language-c++" data-language="c++"><code class="language-c++">int main ()
&#123;
   &#x2F;&#x2F; 局部变量声明
   int a &#x3D; 100;
   int b &#x3D; 200;
 
   cout &lt;&lt; &quot;交换前，a 的值：&quot; &lt;&lt; a &lt;&lt; endl;
   cout &lt;&lt; &quot;交换前，b 的值：&quot; &lt;&lt; b &lt;&lt; endl;
 
   &#x2F;&#x2F; 调用函数来交换值
   swap(a, b);
 
   cout &lt;&lt; &quot;交换后，a 的值：&quot; &lt;&lt; a &lt;&lt; endl;
   cout &lt;&lt; &quot;交换后，b 的值：&quot; &lt;&lt; b &lt;&lt; endl;
 
   return 0;
&#125;</code></pre>

<pre class="language-none"><code class="language-none">交换前，a 的值： 100
交换前，b 的值： 200
交换后，a 的值： 100
交换后，b 的值： 200</code></pre>

<h4 id="指针传递"><a href="#指针传递" class="headerlink" title="指针传递"></a>指针传递</h4><p>把传入参数的<strong>地址</strong>复制给形式参数，<strong>修改形参会影响实参</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 函数定义
void swap(int *x, int *y)
&#123;
   int temp;
   temp &#x3D; *x;    &#x2F;* 保存地址 x 的值 *&#x2F;
   *x &#x3D; *y;        &#x2F;* 把 y 赋值给 x *&#x2F;
   *y &#x3D; temp;    &#x2F;* 把 x 赋值给 y *&#x2F;
  
   return;
&#125;</code></pre>

<pre class="language-c++" data-language="c++"><code class="language-c++">int main ()
&#123;
   &#x2F;&#x2F; 局部变量声明
   int a &#x3D; 100;
   int b &#x3D; 200;
 
   cout &lt;&lt; &quot;交换前，a 的值：&quot; &lt;&lt; a &lt;&lt; endl;
   cout &lt;&lt; &quot;交换前，b 的值：&quot; &lt;&lt; b &lt;&lt; endl;

   &#x2F;* 调用函数来交换值
    * &amp;a 表示指向 a 的指针，即变量 a 的地址 
    * &amp;b 表示指向 b 的指针，即变量 b 的地址 
    *&#x2F;
   swap(&amp;a, &amp;b);

   cout &lt;&lt; &quot;交换后，a 的值：&quot; &lt;&lt; a &lt;&lt; endl;
   cout &lt;&lt; &quot;交换后，b 的值：&quot; &lt;&lt; b &lt;&lt; endl;
 
   return 0;
&#125;</code></pre>

<pre class="language-none"><code class="language-none">交换前，a 的值： 100
交换前，b 的值： 200
交换后，a 的值： 200
交换后，b 的值： 100</code></pre>

<h4 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h4><p>把传入参数的引用的地址复制给形参，在这种情况下，形参就是实参的别名，<strong>修改形参会影响实参</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 函数定义
void swap(int &amp;x, int &amp;y)
&#123;
   int temp;
   temp &#x3D; x; &#x2F;* 保存地址 x 的值 *&#x2F;
   x &#x3D; y;    &#x2F;* 把 y 赋值给 x *&#x2F;
   y &#x3D; temp; &#x2F;* 把 x 赋值给 y  *&#x2F;
  
   return;
&#125;</code></pre>

<pre class="language-c++" data-language="c++"><code class="language-c++">int main ()
&#123;
   &#x2F;&#x2F; 局部变量声明
   int a &#x3D; 100;
   int b &#x3D; 200;
 
   cout &lt;&lt; &quot;交换前，a 的值：&quot; &lt;&lt; a &lt;&lt; endl;
   cout &lt;&lt; &quot;交换前，b 的值：&quot; &lt;&lt; b &lt;&lt; endl;
 
   &#x2F;* 调用函数来交换值 *&#x2F;
   swap(a, b);
 
   cout &lt;&lt; &quot;交换后，a 的值：&quot; &lt;&lt; a &lt;&lt; endl;
   cout &lt;&lt; &quot;交换后，b 的值：&quot; &lt;&lt; b &lt;&lt; endl;
 
   return 0;
&#125;</code></pre>

<pre class="language-none"><code class="language-none">交换前，a 的值： 100
交换前，b 的值： 200
交换后，a 的值： 200
交换后，b 的值： 100</code></pre>

<h3 id="递归调用"><a href="#递归调用" class="headerlink" title="递归调用"></a>递归调用</h3><ul>
<li>递归形式（算法）</li>
<li>修改条件（缩小问题规模）</li>
<li>终止条件</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 求阶乘 n!
int F(int n)&#123;
    if(n &#x3D;&#x3D; 0)&#123; &#x2F;&#x2F; 终止条件
        return 1;
    &#125;else &#123;
        return n * F(n - 1); &#x2F;&#x2F; 修改条件 n &#x3D; n - 1;
    &#125;
&#125;</code></pre>

<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 求斐波那契数列第 n 项
int F(int n)&#123;
    if(n &lt;&#x3D; 2)&#123;
        return 1;
    &#125;else &#123;
        return F(n - 1) + F(n - 2);
    &#125;
&#125;</code></pre>

<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><ul>
<li>每个函数都有一个首地址，称为函数的入口地址（函数指针）</li>
<li><strong>不带括号的函数名</strong>就是函数入口地址</li>
<li>函数调用：找到函数入口地址、传递参数</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303061527827.png" alt="image-20230306152736611" loading="lazy"></p>
<h4 id="函数的地址"><a href="#函数的地址" class="headerlink" title="函数的地址"></a>函数的地址</h4><pre class="language-c++" data-language="c++"><code class="language-c++">void hello()&#123;
    cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl;
&#125;

int main(void)&#123;
    &#x2F;&#x2F; 以下三种方式等效，都能调用 hello 函数
    hello();
    (&amp; hello)();
    (*&amp; hello)();

    cout &lt;&lt; hello &lt;&lt; endl; &#x2F;&#x2F; 函数名是地址
    cout &lt;&lt; (&amp; hello) &lt;&lt; endl; &#x2F;&#x2F; 取函数地址
    cout &lt;&lt; (*&amp; hello) &lt;&lt; endl; &#x2F;&#x2F; 函数地址所指对象

    system(&quot;pause&quot;);
    return 0;
&#125;</code></pre>

<p>注意，<code>&amp; hello</code> 和 <code>*&amp; hello</code> 都会被解析为函数</p>
<h4 id="函数的指针"><a href="#函数的指针" class="headerlink" title="函数的指针"></a>函数的指针</h4><ul>
<li>指向函数的指针称为函数指针</li>
<li>函数的类型是函数的接口</li>
<li>可以通过指针变量的间址方式调用函数</li>
</ul>
<h5 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h5><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 以下为相同类型的函数
int max(int x, int y);
int min(int x, int y);
int avg(int x, int y);</code></pre>

<p>它们的类型为 <code>int (int, int)</code></p>
<h5 id="定义函数类型"><a href="#定义函数类型" class="headerlink" title="定义函数类型"></a>定义函数类型</h5><pre class="language-none"><code class="language-none">typedef 返回值类型 函数类型名 (参数列表)</code></pre>

<p>如</p>
<pre class="language-none"><code class="language-none">typedef int myFunctionType(int, int);</code></pre>

<h5 id="定义指针变量"><a href="#定义指针变量" class="headerlink" title="定义指针变量"></a>定义指针变量</h5><pre class="language-none"><code class="language-none">int (*fp)(int, int);

&#x2F;&#x2F;或
myFunctionType *fp;</code></pre>

<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &quot;windows.h&quot;

using namespace std;

int max(int x, int y);
int min(int x, int y);
int avg(int x, int y);

int main(void)&#123;
    int (*fp) (int, int);

    fp &#x3D; max;
    cout &lt;&lt; fp(1,3) &lt;&lt; endl;

    fp &#x3D; min;
    cout &lt;&lt; fp(1,3) &lt;&lt; endl;

    fp &#x3D; avg;
    cout &lt;&lt; fp(1,3) &lt;&lt; endl;

    system(&quot;pause&quot;);
    return 0;
&#125;

int max(int x, int y)&#123;
	...
&#125;
int min(int x, int y)&#123;
	...
&#125;
int avg(int x, int y)&#123;
    ...
&#125;</code></pre>

<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &quot;windows.h&quot;

using namespace std;

int max(int x, int y);
int min(int x, int y);
int avg(int x, int y);

typedef int myIntType(int, int);

int main(void)&#123;
    myIntType *fp1, *fp2, *fp3;

    fp1 &#x3D; max;
    fp2 &#x3D; min;
    fp3 &#x3D; avg;

    cout &lt;&lt; fp1(1,3) &lt;&lt; endl;
    cout &lt;&lt; fp2(1,3) &lt;&lt; endl;
    cout &lt;&lt; fp3(1,3) &lt;&lt; endl;

    system(&quot;pause&quot;);
    return 0;
&#125;

int max(int x, int y)&#123;
	...
&#125;
int min(int x, int y)&#123;
	...
&#125;
int avg(int x, int y)&#123;
    ...
&#125;
</code></pre>

<p>注意，对于第一个程序 <code>fp = max</code> ，<code>fp</code> 存放的是函数的地址，<code>max</code> 是函数的直接地址</p>
<p>所以 <code>fp</code> 就是 <code>max</code>（<code>&amp;max</code>），而 <code>&amp;fp</code> 不等于 <code>max</code> （<code>&amp;max</code>）</p>
<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>内联函数是 C++ 为降低小规模函数的调用开销的一种机制</p>
<p>这种机制是编译器在编译时，将内联函数的调用以相应代码代替</p>
<p>内联函数声明：<code>inline 函数名()</code></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">inline int hello();

int main(void)&#123;
	...
&#125;

int hello()&#123;
    ...
&#125;</code></pre>

<pre class="language-c++" data-language="c++"><code class="language-c++">inline int hello()&#123;
    ...
&#125;

int main(void)&#123;
	...
&#125;
</code></pre>

<p>错误示例：</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;重复说明，语法错误
inline int hello();

int main(void)&#123;
	...
&#125;

inline int hello()&#123;
    ...
&#125;</code></pre>

<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;视为普通函数，inline 关键字无效
int hello();

int main(void)&#123;

&#125;

inline int hello()&#123;
    ...
&#125;</code></pre>

<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>多个函数：</p>
<ul>
<li>参数个数相同，但类型不同、返回值类型不同</li>
<li>参数个数不同、返回值类型不同</li>
</ul>
<p>上述两种情况均可实现函数重载</p>
<p>另外注意：</p>
<p>仅返回值类型不同，属于语法错误，编译器无法确定唯一函数（函数重定义）</p>
<h3 id="程序内存区域"><a href="#程序内存区域" class="headerlink" title="程序内存区域"></a>程序内存区域</h3><p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303062100261.png" alt="image-20230306210024111" loading="lazy"></p>
<h4 id="自动存储类"><a href="#自动存储类" class="headerlink" title="自动存储类"></a>自动存储类</h4><p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303062101217.png" alt="image-20230306210117065" loading="lazy"></p>
<h4 id="静态存储类"><a href="#静态存储类" class="headerlink" title="静态存储类"></a>静态存储类</h4><ul>
<li>关键字 <code>extern</code> 和 <code>static</code> 声明静态存储变量和函数</li>
<li><code>extern</code> 声明全局，<code>static</code> 声明局部</li>
<li>两者说明变量时，程序开始执行时，就会分配和初始化内存空间，<strong>静态变量默认初始值为 0</strong></li>
<li>两者说明函数时，程序开始执行时，就存在这个函数</li>
</ul>
<h3 id="标识符作用域"><a href="#标识符作用域" class="headerlink" title="标识符作用域"></a>标识符作用域</h3><h4 id="函数原型作用域"><a href="#函数原型作用域" class="headerlink" title="函数原型作用域"></a>函数原型作用域</h4><p>函数原型形式参数列表中的标识符具有函数原型作用域</p>
<p><code>int fun(int, int);</code></p>
<p><code>int fun(int a, int b);</code></p>
<p><code>int fun(int x, int y);</code></p>
<p>三种函数原型，编译器视为相同</p>
<h4 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h4><p>在语句块中声明的标识符具有块作用域</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int main(void)&#123;
    int a &#x3D; 111;
    &#123;
        int a &#x3D; 222;&#x2F;&#x2F; 内层的 a 覆盖了外层的 a
        cout &lt;&lt; a &lt;&lt; endl;
    &#125;
    cout &lt;&lt; a &lt;&lt; endl;

    return 0;
&#125;</code></pre>

<pre class="language-none"><code class="language-none">222
111</code></pre>

<h4 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h4><p>语句标号（后面带冒号的标识符）是唯一具有函数作用域的标识符</p>
<p>如 <code>switch</code> 的 <code>case</code> 标号</p>
<h4 id="文件作用域"><a href="#文件作用域" class="headerlink" title="文件作用域"></a>文件作用域</h4><p>任何在函数之外声明的标识符具有文件作用域</p>
<p>这种标识符从声明处到文件结尾，其中任何函数都可见</p>
<h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><ul>
<li>全局变量：文件作用域</li>
<li>局部变量：函数作用域、块作用域</li>
</ul>
<p><strong>全局变量声明时默认初始值为 0</strong></p>
<p>当局部变量和全局变量同名时，局部变量在块内会覆盖全局变量</p>
<p>若要在块内访问全局变量，则需要域运算符 <code>::</code></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int x;

int main(void)&#123;
    int x &#x3D; 666;

    cout &lt;&lt; x &lt;&lt; endl;
    cout &lt;&lt; ::x &lt;&lt; endl;

    system(&quot;pause&quot;);
    return 0;
&#125;</code></pre>

<pre class="language-none"><code class="language-none">666
0</code></pre>

<h3 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h3><h4 id="C-编译器工作过程"><a href="#C-编译器工作过程" class="headerlink" title="C++ 编译器工作过程"></a>C++ 编译器工作过程</h4><p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303062116313.png" alt="image-20230306211626104" loading="lazy"></p>
<ul>
<li>预处理器：改善程序的组织管理</li>
<li>预处理指令：所有编译指令以 <code>#</code> 开头，每条指令单独占一行</li>
</ul>
<h4 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h4><p><code>include</code> 指令在编译之前，把指定文件包含到该命令所在位置</p>
<p><code>#include &lt;文件名&gt;</code></p>
<p><code>#include &quot;文件名&quot;</code></p>
<h4 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#if 常量表达式
程序段
#endif</code></pre>

<pre class="language-none"><code class="language-none">#if 常量表达式
程序段1
#else
程序段2
#endif</code></pre>

<pre class="language-none"><code class="language-none">#if 常量表达式1
程序段1
#elif 常量表达式2
程序段2
...
#elif 常量表达式n
程序段n
#else
程序段n+1
#endif</code></pre>

<h4 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h4><p>用指定正文替换程序中出现的标识符</p>
<p><code>#define 标识符 文本</code></p>
<p>分号可加可不加</p>
<h5 id="不带参宏定义"><a href="#不带参宏定义" class="headerlink" title="不带参宏定义"></a>不带参宏定义</h5><pre class="language-none"><code class="language-none">#define PI 3.14</code></pre>

<h5 id="带参宏定义"><a href="#带参宏定义" class="headerlink" title="带参宏定义"></a>带参宏定义</h5><pre class="language-none"><code class="language-none">#define getArea(r) PI * r * r</code></pre>

<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><ul>
<li>命名空间是类、函数、对象、类型和其他名字的集合</li>
<li>命名空间可以让程序组件之间不会产生命名冲突</li>
<li><code>std</code> 是 C++ 标准名空间</li>
</ul>
<h4 id="标准名空间"><a href="#标准名空间" class="headerlink" title="标准名空间"></a>标准名空间</h4><p>C++ 标准头文件没有扩展名 <code>.h</code></p>
<p>如</p>
<pre class="language-none"><code class="language-none">iostream  iomanip  limit  fstream  string  typeinfo  stdexcept</code></pre>

<p>使用标准类库的组件时，需要指定名空间</p>
<p>C++ 标准名空间 <code>std</code></p>
<h4 id="使用标准名空间"><a href="#使用标准名空间" class="headerlink" title="使用标准名空间"></a>使用标准名空间</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;

using namespace std;

int main()&#123; 
    int a, b;
    cin &gt;&gt; a;			
    cin &gt;&gt; b;			
    cout &lt;&lt; a+b &lt;&lt; endl; 	
&#125;</code></pre>

<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;

using std::cin; 
using std::cout;

int main()&#123; 
    int a, b;
	cin &gt;&gt; a;	
	cin &gt;&gt; b;	
	cout &lt;&lt; a+b &lt;&lt; endl; 
&#125;</code></pre>

<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;

int main()&#123; 
    int a, b;
	std::cin &gt;&gt; a;
	std::cin &gt;&gt; b;
	std::cout &lt;&lt; a+b &lt;&lt; std::endl; 
&#125;</code></pre>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>数组是由一定数量的<strong>同类元素</strong>，按顺序排列而成的数据结构</li>
<li>一个数组在内存中占有一块连续的内存区域</li>
<li><strong>数组名就是数组首元素的地址</strong></li>
<li>数组每个元素由下标进行表示</li>
</ul>
<h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>元素是基本类型、结构类型或类</p>
<p>一维数组也可视为<strong>向量</strong></p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><code>类型 标识符[表达式]</code></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int A[10];
char B[MaxSize];
double C[m*n];</code></pre>

<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 为数组赋初值
int a[5] &#x3D; &#123;1,2,3,4,5&#125;;

&#x2F;&#x2F; 全部初始化为0
int b[10] &#x3D; &#123;0&#125;;

&#x2F;&#x2F; 第0、1、2号元素赋初值，其他为0
int c[10] &#x3D; &#123;1,2,3&#125;;

&#x2F;&#x2F; 自动推断数组长度为5
int d[] &#x3D; &#123;1,2,3,4,5&#125;</code></pre>

<h4 id="下标访问"><a href="#下标访问" class="headerlink" title="下标访问"></a>下标访问</h4><p><code>数组名 [表达式]</code></p>
<h4 id="指针访问"><a href="#指针访问" class="headerlink" title="指针访问"></a>指针访问</h4><pre class="language-c++" data-language="c++"><code class="language-c++">int a[5] &#x3D; &#123;1,2,3,4,5&#125;;

&#x2F;&#x2F; 数组名是首元素地址
a &#x3D;&#x3D; &amp;a[0]
a+1 &#x3D;&#x3D; &amp;a[1]

&#x2F;&#x2F; 指针访问
*a &#x3D;&#x3D; a[0]
*(a+1) &#x3D;&#x3D; a[1]</code></pre>

<h3 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h3><p>元素类型为指针的数组</p>
<p>每个指针元素都存放了某个地址</p>
<p><code>类型 * 标识符[表达式]</code></p>
<h4 id="指向基本元素的指针数组"><a href="#指向基本元素的指针数组" class="headerlink" title="指向基本元素的指针数组"></a>指向基本元素的指针数组</h4><pre class="language-c++" data-language="c++"><code class="language-c++">int a &#x3D; 1;
int b &#x3D; 2;
int c &#x3D; 3;

int * pArr[3];

pArr[0] &#x3D; &amp;a;
pArr[1] &#x3D; &amp;b;
pArr[2] &#x3D; &amp;c;

cout &lt;&lt; *pArr[0] &lt;&lt; endl;
cout &lt;&lt; *pArr[1] &lt;&lt; endl;
cout &lt;&lt; *pArr[2] &lt;&lt; endl;</code></pre>

<pre class="language-none"><code class="language-none">1
2
3</code></pre>

<h4 id="指向数组的指针数组"><a href="#指向数组的指针数组" class="headerlink" title="指向数组的指针数组"></a>指向数组的指针数组</h4><pre class="language-c++" data-language="c++"><code class="language-c++">int a[2] &#x3D; &#123;1,2&#125;;
int b[2] &#x3D; &#123;3,4&#125;;
int c[2] &#x3D; &#123;5,6&#125;;

int (*pArr[3])[2];

pArr[0] &#x3D; &amp;a;
pArr[1] &#x3D; &amp;b;
pArr[2] &#x3D; &amp;c;

for(int i &#x3D; 0; i &lt; 3; i++)&#123;
    for(int j &#x3D; 0; j &lt; 2; j++)&#123;
        cout &lt;&lt; *(*pArr[i] + j) &lt;&lt; endl;
    &#125;
&#125;</code></pre>

<p>关于本例中 <code>a</code> 和 <code>&amp;a</code>：</p>
<p><code>a</code> 作为一个数组名，本身就是首元素地址</p>
<p> <code>&amp;a</code> 没有实际意义，与 <code>a</code> 等效，首元素地址</p>
<p>但是注意：</p>
<p><code>pArr[]</code> 数组元素（指针）指向一维数组，其元素类型为<strong>二级指针</strong></p>
<p>而 <code>a</code> 是<strong>一级指针</strong>，若写成 <code>pArr[0] = a</code> 则会报错</p>
<p>所以需要写成<code>pArr[0] = &amp;a</code>，两边逻辑上都是<strong>二级指针</strong></p>
<h4 id="指向函数的指针数组"><a href="#指向函数的指针数组" class="headerlink" title="指向函数的指针数组"></a>指向函数的指针数组</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &quot;windows.h&quot;

using namespace std;

const double PI &#x3D; 3.14;

double getArea(double r)&#123;
    return PI * r * r;
&#125;

double getGirth(double r)&#123;
    return 2 * PI * r;
&#125;

&#x2F;&#x2F; 定义函数类型
typedef double circleFunction(double);

int main(void)&#123;
    &#x2F;&#x2F; 利用函数类型，定义函数指针
    circleFunction * pArr[2];

    pArr[0] &#x3D; getArea;
    pArr[1] &#x3D; getGirth;

    cout &lt;&lt; (*pArr[0])(3.0) &lt;&lt; endl;
    cout &lt;&lt; (*pArr[1])(3.0) &lt;&lt; endl;

    system(&quot;pause&quot;);
    return 0;
&#125;</code></pre>

<pre class="language-none"><code class="language-none">28.26
18.84</code></pre>

<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>元素类型为<strong>一维数组</strong>的数组</p>
<p>其中的每个一维数组<strong>元素类型相同</strong>、<strong>长度相同</strong></p>
<h4 id="下标访问-1"><a href="#下标访问-1" class="headerlink" title="下标访问"></a>下标访问</h4><p><code>数组名[表达式1][表达式2]</code></p>
<h4 id="指针访问-1"><a href="#指针访问-1" class="headerlink" title="指针访问"></a>指针访问</h4><pre class="language-c++" data-language="c++"><code class="language-c++">int a[3][5];</code></pre>

<p>二维数组名 <code>a</code> 是<strong>逻辑上</strong>的二级指针，<code>a[i]</code> 是一级指针</p>
<p>但是，二维数组名<strong>不能直接赋给二级指针变量</strong>，因为<strong>无论 n 维数组，数组名都是首元素地址</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int *p1;
int **p2;

&#x2F;&#x2F; 正确
p1 &#x3D; *a;
p1 &#x3D; a[0];

&#x2F;&#x2F; 错误
p1 &#x3D; a;
p2 &#x3D; a;</code></pre>

<h5 id="求元素地址"><a href="#求元素地址" class="headerlink" title="求元素地址"></a>求元素地址</h5><pre class="language-none"><code class="language-none">&#x2F;&#x2F; 第0行第1列的元素地址
a[0] + 1
*a + 1
&amp;a[0][1]</code></pre>

<pre class="language-none"><code class="language-none">&#x2F;&#x2F; 第3行第4列的元素地址
a[3] + 4
*(a + 3) + 4
&amp;a[3][4]</code></pre>

<pre class="language-none"><code class="language-none">&#x2F;&#x2F; 第i行第j列的元素地址
a[i] + j
*(a + i) + j
&amp;a[i][j]</code></pre>

<h5 id="求元素的值"><a href="#求元素的值" class="headerlink" title="求元素的值"></a>求元素的值</h5><pre class="language-none"><code class="language-none">&#x2F;&#x2F; 第1行第2列元素的值
*(a[1] + 2)
*(*(a + 1) + 2)
a[1][2]</code></pre>

<pre class="language-none"><code class="language-none">&#x2F;&#x2F; 第i行第j列元素的值
*(a[i] + j)
*(*(a + i) + j)
a[i][j]</code></pre>

<h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><pre class="language-c++" data-language="c++"><code class="language-c++">int a[3][5] &#x3D; &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15&#125;;
int *p;

for(p &#x3D; a[0]; p &lt; a[0] + 15; p++)&#123;
    cout &lt;&lt; *p &lt;&lt; endl;
&#125;

for(p &#x3D; *a; p &lt; *a + 15; p++)&#123;
    cout &lt;&lt; *p &lt;&lt; endl;
&#125;

for(int i &#x3D; 0; i &lt; 3; i++)&#123;
    for(int j &#x3D; 0; j &lt; 5; j++)&#123;
        cout &lt;&lt; *(a[i] + j) &lt;&lt; endl;
    &#125;
&#125;</code></pre>

<ul>
<li><p>可以改为 <code>p = a</code> 吗？</p>
<p>NO.</p>
<p><code>a</code> 是逻辑上的二级指针，不能赋给一级指针变量 <code>p</code></p>
</li>
<li><p>可以改为 <code>p = a[0][0]</code> 吗？</p>
<p>NO.</p>
<p><code>a[0][0]</code> 是元素值</p>
</li>
<li><p>可以改为 <code>p = &amp;a[0][0]</code> 吗？</p>
<p>YES.</p>
</li>
</ul>
<h3 id="一维数组作为函数参数"><a href="#一维数组作为函数参数" class="headerlink" title="一维数组作为函数参数"></a>一维数组作为函数参数</h3><ul>
<li>数组作为参数，与一般变量相同</li>
<li>数组名作为参数时，传递首元素地址</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">int sumArr(int arr[], int len)&#123;
    int sum &#x3D; 0;

    &#x2F;&#x2F; arr 本质是一个指针
    for(int i &#x3D; 0; i &lt; len; i++)&#123;
        sum +&#x3D; *arr;
        arr++;
    &#125;

    return sum;
&#125;

int main(void)&#123;
    int a[3] &#x3D; &#123;1, 2, 3&#125;;

    cout &lt;&lt; sumArr(a, 3) &lt;&lt; endl;

    system(&quot;pause&quot;);
    return 0;
&#125;</code></pre>

<pre class="language-none"><code class="language-none">6</code></pre>

<blockquote>
<p>形式参数 <code>int arr[]</code> 本质上就是一个普通指针，等价于 <code>int * arr</code></p>
</blockquote>
<p>也可以换成：</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">for(int i &#x3D; 0; i &lt; len; i++)&#123;
    sum +&#x3D; arr[i];
&#125;</code></pre>

<h3 id="二维数组作为函数参数"><a href="#二维数组作为函数参数" class="headerlink" title="二维数组作为函数参数"></a>二维数组作为函数参数</h3><p>以下是常见错误：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a[%d][%d]=%d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#123;</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token function">foo</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>报错：</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">$ gcc test.c
test.c:3:14: error: array <span class="token builtin class-name">type</span> has incomplete element <span class="token builtin class-name">type</span> ‘int<span class="token punctuation">[</span><span class="token punctuation">]</span>’
 void foo<span class="token punctuation">(</span>int p<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span>, int m, int n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
              ^
test.c: In <span class="token keyword">function</span> ‘main’:
test.c:12:9: error: <span class="token builtin class-name">type</span> of formal parameter <span class="token number">1</span> is incomplete
     foo<span class="token punctuation">(</span>a, <span class="token number">2</span>, <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>报错原因：</p>
<p>C 语言对二维数组的存储是按一维数组来处理的，按照行展开，然后顺序存储</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int a[2][3] &#x3D; &#123;
        &#123;1,2,3&#125;,
        &#123;4,5,6&#125;
&#125;;</code></pre>

<pre class="language-c++" data-language="c++"><code class="language-c++">int b[6] &#x3D; &#123;
        &#123;1,2,3,4,5,6&#125;
&#125;;</code></pre>

<p>两者在内存中的存储顺序是一致的</p>
<pre class="language-none"><code class="language-none">---+---+--+---+--+--+-------
a: | 1 | 2 | 3 | 4 | 5 | 6
b: | 1 | 2 | 3 | 4 | 5 | 6
---+---+--+---+--+--+-------</code></pre>

<p>所以在利用二维数组作为参数传递时，<strong>必须指定二维数组的列数</strong>，行数可写可不写，如下所示</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">void foo(int a[][3], int m, int n) &#123;
    int i &#x3D; 1;
    int j &#x3D; 1;
    printf(&quot;a[%d][%d]&#x3D;%d\n&quot;, i, j, a[i][j]);
&#125;</code></pre>

<h3 id="动态存储"><a href="#动态存储" class="headerlink" title="动态存储"></a>动态存储</h3><p>C++ 的动态存储分配机制可以在程序运行时建立和撤销对象</p>
<h4 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a>new 操作符</h4><p>动态分配堆内存</p>
<p><code>指针变量 = new 类型 (常量)</code>，常量可缺省</p>
<p><code>指针变量 = new 类型 [表达式]</code></p>
<p>从堆内存分配一块该类型大小的存储空间，并返回首地址</p>
<h4 id="delete-操作符"><a href="#delete-操作符" class="headerlink" title="delete 操作符"></a>delete 操作符</h4><p>释放已分配的内存空间</p>
<p><code>delete 指针变量</code></p>
<p><code>delete [] 指针变量</code></p>
<p>其中指针变量必须是 new 返回的</p>
<h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><pre class="language-c++" data-language="c++"><code class="language-c++">int * p1 &#x3D; new int;
char * p2 &#x3D; new char;
double * p3 &#x3D; new double;
int * p4 &#x3D; new int[4];

delete p1;
delete p2;
delete p3;
delete [] p4;</code></pre>

<pre class="language-c++" data-language="c++"><code class="language-c++">int * p &#x3D; NULL;
p &#x3D; new int (114514); &#x2F;&#x2F; 该int无名，只能通过p指针访问</code></pre>

<h3 id="字符数组与字符串"><a href="#字符数组与字符串" class="headerlink" title="字符数组与字符串"></a>字符数组与字符串</h3><p>C++ 没有字符串类型，以字符数组作为字符串</p>
<p><code>&#39;\0&#39;</code> 是字符串结束的标志，ascii 码为 0</p>
<p>字符数组作为字符串初始化时，自动添加<code>&#39;\0&#39;</code></p>
<h4 id="用字符数组存放字符串"><a href="#用字符数组存放字符串" class="headerlink" title="用字符数组存放字符串"></a>用字符数组存放字符串</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> s1<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">'t'</span><span class="token punctuation">,</span> <span class="token string">'u'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'n'</span><span class="token punctuation">,</span> <span class="token string">'t'</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<pre class="language-c++" data-language="c++"><code class="language-c++">char s2[10] &#x3D; &#123;&quot;student&quot;&#125;;
char s3[] &#x3D; &#123;&quot;student&quot;&#125;;
char s4[] &#x3D; &quot;student&quot;;</code></pre>

<h4 id="用字符指针管理字符串"><a href="#用字符指针管理字符串" class="headerlink" title="用字符指针管理字符串"></a>用字符指针管理字符串</h4><pre class="language-c++" data-language="c++"><code class="language-c++">char *s &#x3D; &quot;student&quot;;</code></pre>

<h4 id="字符串的访问"><a href="#字符串的访问" class="headerlink" title="字符串的访问"></a>字符串的访问</h4><p>iostream 对字符串的扩展功能：</p>
<ul>
<li>字符串常量、字符数组名、字符指针都可以表示字符串</li>
<li><strong>输出字符指针就是输出整个字符串</strong></li>
<li>数组字符指针的间接引用是输出单个字符</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">char * s &#x3D; &quot;student&quot;;

cout &lt;&lt; s &lt;&lt; endl; &#x2F;&#x2F; 输出 student
cout &lt;&lt; *s &lt;&lt; endl; &#x2F;&#x2F; 输出 s</code></pre>

<pre class="language-c++" data-language="c++"><code class="language-c++">char s[3] &#x3D; &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;;
cout &lt;&lt; s &lt;&lt; endl; &#x2F;&#x2F; 输出 abc?@ 后两个为无意义字符，因为找不到 &#39;\0&#39;</code></pre>

<pre class="language-c++" data-language="c++"><code class="language-c++">static char s[3] &#x3D; &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;;
cout &lt;&lt; s &lt;&lt; endl; &#x2F;&#x2F; 正确输出 abc 因为静态数组自动对剩余元素初始化为 &#39;\0&#39;</code></pre>

<pre class="language-c++" data-language="c++"><code class="language-c++">char s[] &#x3D; &quot;abc&quot;;
cout &lt;&lt; s &lt;&lt; endl; &#x2F;&#x2F; 正确输出 abc</code></pre>

<h4 id="输入字符串"><a href="#输入字符串" class="headerlink" title="输入字符串"></a>输入字符串</h4><pre class="language-c++" data-language="c++"><code class="language-c++">char s[10]; &#x2F;&#x2F; 数组长度不能省略，否则报错
cin &gt;&gt; s;
cout &lt;&lt; s &lt;&lt; endl;</code></pre>

<pre class="language-none"><code class="language-none">in: abc
out: abc</code></pre>

<h4 id="特例"><a href="#特例" class="headerlink" title="特例"></a>特例</h4><pre class="language-c++" data-language="c++"><code class="language-c++">char *s &#x3D; &quot;student&quot;;

for(int i &#x3D; 0; i &lt; 7; i++)&#123;
    cout &lt;&lt; *(s+i) &lt;&lt; endl;
&#125;</code></pre>

<pre class="language-none"><code class="language-none">s
t
u
d
e
n
t</code></pre>

<pre class="language-c++" data-language="c++"><code class="language-c++">char *s &#x3D; &quot;student&quot;;

for(int i &#x3D; 0; i &lt; 7; i++)&#123;
    cout &lt;&lt; (s+i) &lt;&lt; endl;
&#125;</code></pre>

<pre class="language-none"><code class="language-none">student
tudent
udent
dent
ent
nt
t</code></pre>

<h4 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h4><p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303071718583.png" alt="image-20230307171831248" loading="lazy"></p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li>结构由固定数目的成员组成</li>
<li>各成员可以是不同的数据类型</li>
<li>一个<strong>结构变量整体</strong>，在内存中占有连续的一块内存空间</li>
</ul>
<h3 id="定义结构"><a href="#定义结构" class="headerlink" title="定义结构"></a>定义结构</h3><pre class="language-c++" data-language="c++"><code class="language-c++">struct 结构名 &#123;
    类型 成员1;
    类型 成员2;
    ...
&#125;;</code></pre>

<h3 id="定义结构及变量"><a href="#定义结构及变量" class="headerlink" title="定义结构及变量"></a>定义结构及变量</h3><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 声明类型之后，声明变量
struct student &#123;
    char name[10];
    int age;
&#125;;

student s1;
student s2;
...</code></pre>

<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 声明类型同时，声明变量
struct student &#123;
    char name[10];
    int age;
&#125;s1, s2, *Stu;</code></pre>

<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 直接声明变量，且无结构名
struct &#123;
    char name[10];
    int age;
&#125;s1, s2, *Stu;</code></pre>

<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 一个结构，可以是另一结构的成员类型
struct date &#123;
    int year;
    int month;
    int day;
&#125;;

struct student &#123;
    char name[10];
    int age;
    date birthday;
&#125;s1, s2;

&#x2F;&#x2F; 报错，成员类型不能是自身所在的结构类型，即不能是递归结构
struct person &#123;
    person father;
    person mother;
&#125;</code></pre>

<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 声明结构的同时，可以初始化结构变量
struct student &#123;
    char name[10];
    int age;
&#125;s1 &#x3D; &#123;&quot;alice&quot;, 18&#125;;</code></pre>

<h3 id="访问结构"><a href="#访问结构" class="headerlink" title="访问结构"></a>访问结构</h3><p><code>结构变量.成员</code></p>
<p>如</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">s1.name
s1.age</code></pre>

<h4 id="指针访问-2"><a href="#指针访问-2" class="headerlink" title="指针访问"></a>指针访问</h4><p><code>结构指针-&gt;成员</code></p>
<p><code>(*结构指针).成员</code></p>
<h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &quot;windows.h&quot;
#include &lt;cstring&gt; &#x2F;&#x2F; 注意 strcpy() 需要加上文件头

using namespace std;

struct student &#123;
    char name[10];
    int age;
&#125;;

int main(void)&#123;
    student s1;
    student *stuPointer;

    stuPointer &#x3D; &amp;s1;

    strcpy(stuPointer-&gt;name, &quot;alice&quot;); 
    stuPointer-&gt;age &#x3D; 18;

    cout &lt;&lt; stuPointer-&gt;name &lt;&lt; endl;
    cout &lt;&lt; stuPointer-&gt;age &lt;&lt; endl;

    system(&quot;pause&quot;);
    return 0;
&#125;</code></pre>

<pre class="language-none"><code class="language-none">alice
18</code></pre>

<p>注意，这里对 <code>name[]</code> 数组赋值必须使用 <code>strcpy()</code> 函数</p>
<p>写成 <code>stuPointer-&gt;name = &quot;alice&quot;</code> 则会报错</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">incompatible types in assignment of &#39;const char [6]&#39; to &#39;char [10]&#39;</code></pre>

<h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &quot;windows.h&quot;
#include &lt;cstring&gt;

using namespace std;

struct student &#123;
    char name[10];
    int age;
&#125;;

int main(void)&#123;
    student s1;
    student *stuPointer;

    stuPointer &#x3D; &amp;s1;

    strcpy((*stuPointer).name, &quot;alice&quot;);
    (*stuPointer).age &#x3D; 18;

    cout &lt;&lt; stuPointer-&gt;name &lt;&lt; endl;
    cout &lt;&lt; stuPointer-&gt;age &lt;&lt; endl;

    system(&quot;pause&quot;);
    return 0;
&#125;</code></pre>

<h5 id="类型相同的结构变量可以相互赋值"><a href="#类型相同的结构变量可以相互赋值" class="headerlink" title="类型相同的结构变量可以相互赋值"></a>类型相同的结构变量可以相互赋值</h5><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &quot;windows.h&quot;
#include &lt;cstring&gt;

using namespace std;

struct student &#123;
    char name[10];
    int age;
&#125;;

int main(void)&#123;
    student s1;
    student s2;

    strcpy(s1.name, &quot;alice&quot;);
    s1.age &#x3D; 18;

    s2 &#x3D; s1;

    cout &lt;&lt; s2.name &lt;&lt; endl;
    cout &lt;&lt; s2.age &lt;&lt; endl;

    system(&quot;pause&quot;);
    return 0;
&#125;</code></pre>

<pre class="language-none"><code class="language-none">alice
18</code></pre>

<h3 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &quot;windows.h&quot;
#include &lt;cstring&gt;

using namespace std;

struct student &#123;
    char name[10];
    int age;
&#125;;

int main(void)&#123;
    student stuArr[3];

    strcpy(stuArr[0].name, &quot;alice&quot;);
    stuArr[0].age &#x3D; 18;

    strcpy(stuArr[1].name, &quot;bob&quot;);
    stuArr[1].age &#x3D; 20;

    strcpy(stuArr[2].name, &quot;clever&quot;);
    stuArr[2].age &#x3D; 22;

    for(int i &#x3D; 0; i &lt; 3; i++)&#123;
        cout &lt;&lt; stuArr[i].name &lt;&lt; endl;
        cout &lt;&lt; stuArr[i].age &lt;&lt; endl;
    &#125;

    system(&quot;pause&quot;);
    return 0;
&#125;</code></pre>

<pre class="language-none"><code class="language-none">alice
18
bob
20
clever
22</code></pre>

<h3 id="结构内存对齐原则"><a href="#结构内存对齐原则" class="headerlink" title="结构内存对齐原则"></a>结构内存对齐原则</h3><p>先看一个例子</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">struct s1 &#123;
    char c1;
    int i;
    char c2;
&#125;;</code></pre>

<p>这个结构体所占用的内存空间大小是 12 字节，而不是 6 字节77</p>
<p>为什么？</p>
<p>因为 c 语言中，结构体需要遵循内存对齐原则</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303101546593.png" alt="c264ec88a608e28d18ce5897d2c31dfd.png" loading="lazy"></p>
<p>简单来说，对齐数就是取 <code>&lt;变量大小， 8字节&gt;</code> 两者之间的较小者</p>
<p>如 char 变量对齐数是 1</p>
<p>int 变量对齐数是 4</p>
<p>一个占用 16 字节内存空间的结构体变量（嵌套），对齐数是 8</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303101550650.png" alt="9d7e61342fe649ed67e60ebafb5d81d8.png" loading="lazy"></p>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><pre class="language-c++" data-language="c++"><code class="language-c++">struct s2 &#123;
    char c1;
    char c2;
    int i;
&#125;;</code></pre>

<p>s1、s2 的区别仅是变量 <code>i、c2</code> 互换了位置</p>
<p>这个结构体的大小却变成了 8</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303101552350.png" alt="image-20230310155213224" loading="lazy"></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">struct s3 &#123;
    double d;
    char c;
    int i;
&#125;;</code></pre>

<p>s3 结构体的大小为 16</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">struct s3 &#123;
    double d;
    char c;
    int i;
&#125;;

struct s4 &#123;
    char c1; &#x2F;&#x2F; 放在 0 号位置
    struct s3 s; &#x2F;&#x2F;  放在 8 号位置
    double d; &#x2F;&#x2F; 放在 24 号位置
&#125;</code></pre>

<p>结构体 s4 的大小为 32</p>
<p><code>&lt;结构体s3的大小==16, 8&gt;</code> 之间取小者，对齐数为 8</p>
<p>所以 <code>c1</code> 位于 0，<code>s3</code> 位于 8， <code>d</code> 位于 24（8号+16字节）</p>
<h4 id="为什么需要内存对齐？"><a href="#为什么需要内存对齐？" class="headerlink" title="为什么需要内存对齐？"></a>为什么需要内存对齐？</h4><h5 id="观点一：可移植性"><a href="#观点一：可移植性" class="headerlink" title="观点一：可移植性"></a>观点一：可移植性</h5><p>不是所有的硬件平台都能访问任意地址上的任意数据的</p>
<p>某些硬件平台只能在某些地址处取数据，否则抛出硬件异常</p>
<h5 id="观点二：性能"><a href="#观点二：性能" class="headerlink" title="观点二：性能"></a>观点二：性能</h5><p>数据结构(尤其是栈)应该尽可能地在自然边界上对齐</p>
<p>原因在于：</p>
<p>若访问<strong>未对齐</strong>的内存，处理器需要作两次内存访问</p>
<p>若访问<strong>对齐</strong>的内存，仅需要一次访问</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rayucan/imageCloud/data/202303101601919.png" alt="36f4ddc454649072dfe2d90affd742e4.png" loading="lazy"></p>
</div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>丁真</li><li class="post-copyright-link"><strong>Post link: </strong><a href="http://example.com/2023/03/03/cpp/" title="C++">http://example.com/2023/03/03/cpp/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless otherwise stated.</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2023/03/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="prev" title="机器学习"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">机器学习</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2023/02/23/%E7%BD%91%E5%AE%89%E5%9F%BA%E7%A1%80/" rel="next" title="网安基础"><span class="post-nav-text">网安基础</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>要不要和我说些什么？</span><br></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2020 – 2023 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> 丁真</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v5.4.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.6.1</span></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div></body></html>